package generics_11;

/* Всякий раз, когда определяется обобщенный тип, автоматически создается
соответствующий ему базовый (так называемый "сырой") тип. Имя этого типа совпадает
с именем обобщенного типа с удаленными параметрами типа. Переменные
типа стираются и заменяются ограничивающими типами (или типом O bject, если
переменная не имеет ограничений). Например, базовый тип для обобщенного типа
GeneralizedClass <T, U> выглядит следующим образом.

Если T — неограниченная переменная типа, то ее тип просто заменяется
на Object. В итоге получается обычный класс вроде тех, что реализовывались до появления обобщений в Java.

Базовый тип заменяет тип переменных первым накладываемым на них ограничением или же типом
Object , если никаких ограничений не предусмотрено. Например, у переменной типа в обобщенном классе
eneralizedClass <T, U> отсутствуют явные ограничения, и поэтому базовый тип заменяет обобщенный тип Т, U на Object.
Но если есть ограничение, то базовым типом становиться тип первого ограничения. Поэтому ради эффективности в конце
списка ограничений следует размещать отмечающие интерфейсы (т.е. интерфейсы без методов).

Когда в программе вызывается обобщенный метод, компилятор вводит операции
приведения типов при стирании возвращаемого типа.
Операции приведения типов вводятся также при обращении к обобщенному
полю.

Таким образом, о преобразовании обобщений в Java нужно запомнить следующее:
    1. Для виртуальной машины обобщений не существует, но имеются только обычные классы и методы.
    2. Все параметры типа заменяются ограничивающими типами.
    3. Мостовые методы синтезируются для соблюдения принципа полиморфизма.
    3. Операции приведения типов вводятся по мере надобности для обеспечения
       типовой безопасности.



*/
public class ErasingTypes {

    private Object name;
    private Object age;
    private Object number;

    public ErasingTypes(Object name, Object age, Object number) {

        this.name = name;
        this.age = age;
        this.number = number;
    }

    public Object getName() {
        return name;
    }

    public Object getAge() {
        return age;
    }

    public Object getNumber() {
        return number;
    }
}
