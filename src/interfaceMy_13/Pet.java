package interfaceMy_13;


/*Интерфейс в Java решает проблему множественного наследования,
разрешая вам пользоваться преимуществами этого наследования без
негативных последствий от «Смертоносного Ромба Смерти»

Свойства интерфейса:
    1. Интерфейс - это практически на 100% чистый абстрактный класс
    2. Методы интерфейса неявно являются публичными и абстрактными


Когда вы используете интерфейс как полиморфический тип (например, массив для
объектов Pet), объекты могут быть откуда угодно. Единственное
требование — они должны содержать класс, который реализует этот интерфейс.
Возможность классов из разных иерархий наследования переопределять
общий интерфейс — ключевая особенность в Java API. Хотите, чтобы
объект сохранял свое состояние в файл? Реализуйте интерфейс
Serializable. Хотите, чтобы объекты запускали свои методы в отдельных
потоках? Реализуйте Runnable.


Как узнать, когда нужно создавать класс, подкласс, абстрактный класс
или интерфейс:
    1. Создавайте класс, который ничего не наследует (не считая Object),
    когда ваш новый класс не проходит проверку на соответствие другим типам.
    2. Создавайте дочерний класс, только когда вам нужно сделать более
    специфичную версию родительского  класса и заменить или добавить
    новое поведение.
    3. Используйте абстрактный класс, когда хотите определить шаблон
    для группы подклассов и у вас есть хоть какой-нибудь код реализации,
    который смогут применять все подклассы. Делайте класс абстрактным, когда
    хотите получить гарантию того, что никто не сможет создать объекты данного типа.
    3. Пользуйтесь интерфейсом, когда хотите определить роль, которую
    смогут играть другие классы, невзирая на то, где они находятся в
    иерархии наследования.

Интерфейс позволяет указывать, что именно должны делать классы,
не уточняя, как именно они должны это делать.

Интерфейс в Java не является классом. Он представляет собой ряд требований,
предъявляемых к классу, который должен соответствовать интерфейсу.

Все методы интерфейса автоматически считаются открытыми, поэтому, объявляя
метод в интерфейсе, указывать модификатор доступа public необязательно.

У интерфейсов отсуттсвуют поля

Интерфейсы — это не классы. В частности, с помощью операции new нельзя
создать экземпляр интерфейса

Но, несмотря на то, что конструировать интерфейсные объекты нельзя, объявлять
интерфейсные переменные можно

Аналогично классам, интерфейсы также могут образовывать иерархию наследования.
Это позволяет создавать цепочки интерфейсов в направлении от более абстрактных
к более специализированным.


В интерфейсах разрешается:
    1. Объявлять константы: поля в интерфейсах автоматически становяться
       public static final, даже если явно не указаны данные ключевые слова.
       Если указать при объявлении константы public static final, то это не
       будет считатья ошибкой, но в спецификации Java не рекомендуется
       употреблять лишние ключевые слова.
       Константы интерфейса доступны для класса реализующего интерфейс и до
       наследников данного класса по цепочке наследования.

    2. Объявлять абстрактные методы: все методы в интерфейсе автоматически
       являються открытыми, без явного указания модификатора доступа public

    3. Объявлять статические методы.

    4. Объявлять методы по умолчанию: методы по умолчанию необязательно
    реализовывать в классах реализующих интерфейс, но они доступны для вызова.
    Данные методы хороши, когда необходимо добавить методы в уже использующийся
    интерфейс, при этом не нарушив совметимость.

Конфликты методов по умолчанию.
Если метод по умолчанию определен в нескольких нтерфейсах с одним именем или
с таким же именем в супер классе, то возникает конфлик имен, который решается
следующим образом:
    1. В конфликте верх одерживает суперкласс. Если суперкласс предоставляет
    конкретный метод, то методы по умолчанию с одинаковыми именами и типами
    параметров просто игнорируются

    2. Интерфейсы вступают в конфликт. Если суперинтерфейс предоставляет метод,
    а другой интерфейс — метод (по умолчанию или иначе) с таким же самым
    именем и типами параметров, то для разрешения конфликта необходимо
    переопределить этот метод.




*/


import java.util.Arrays;

public interface Pet {

    /*Объявление константы*/
    int ID = 123;

    /* Объявление абстрактного метода */
    abstract void beFriendly();
    abstract void play();

    /* Объявление статического метода с переменным числом
    параметров */
    static String createRation(String...food) {
        return Arrays.toString(food);
    }

    /* Метод по умолчанию */
    default void print() {
        System.out.println("!!!!!!!!!!!!!");
    }



}
