package design_patterns;

/*
Уровень/Цель      Порождающие паттерны            Структурные паттерны         Паттерны поведени

Класс             Фабричный метод                  Адаптер (класса)            Интерпретатор
                                                                               Шаблонный метод

Объект            Абстрактная фабрика              Адаптер (объекта)           Итератор
                  Одиночка                         Декоратор                   Команда
                  Прототип                         Заместитель                 Наблюдатель
                  Строитель                        Компоновщик                 Посетитель
                                                   Мост                        Посредник
                                                   Приспособленец              Состояние
                                                   Фасад                       Стратегия
                                                                               Хранитель
                                                                               Цепочка обязанностей
Цель - отражает назначение паттерна
Уровень - говорит о том, к чему обычно применяется паттерн: к объектам или классам.

Порождающие патерны связаны с процессом создания объектов. Эти паттерны оказываются важны, когда система больше
зависит от композиции объектов, чем от наследования классов. Для порождающих паттернов актуальны две темы.
Во-первых, эти паттерны инкапсулируют знания о конкретных классах, которые применяются в системе.
Во-вторых, скрывают детали того, как эти классы создаются и стыкуются. Единственная информация об объектах,
известная системе, - это их интерфейсы, определенные с помощью абстрактных классов. Следовательно, порождающие паттерны
обеспечивают большую гибкость при решении вопроса о том, что создается, кто это создает, как и когда. Можно собрать
систему из «готовых» объектов с самой различной структурой и функциональностью статически (на этапе компиляции) или
динамически (во время выполнения).


 Вторые имеют отношение к композиции объектов и классов.
Паттерны поведения характеризуют то, как классы или объекты взаимодействуют между собой.



Паттерны уровня классов описывают отношения
между классами и их подклассами. Такие отношения выражаются с помощью наследования, поэтому они статичны, то есть
зафиксированы на этапе компиляции. Паттерны уровня объектов описывают отношения между объектами, которые могут
изменяться во время выполнения и потому более динамичны. Почти все паттерны в какой-то мере используют наследование.
Поэтому к категории «паттерны классов» отнесены только те, что сфокусированы лишь на отношениях между классами.
Обратите внимание: большинство паттернов действуют на уровне объектов.

Порождающие паттерны классов частично делегируют ответственность за создание объектов своим подклассам, тогда как
порождающие паттерны объектов передают ответственность другому объекту. Структурные паттерны классов используют
наследование для составления классов, в то время как структурные паттерны объектов описывают способы сборки объектов из
частей. Поведенческие паттерны классов используют наследование для описания алгоритмов и потока управления, а
поведенческие паттерны объектов описывают, как объекты, принадлежащие некоторой группе, совместно функционируют и
выполняют задачу, которая ни одному отдельному объекту не под силу.

Наследование и композиция
Два наиболее распространенных приема повторного использования функциональности в объектно-ориентированных системах - это наследование класса
и композиция объектов. Как мы уже объясняли, наследование класса позволяет
определить реализацию одного класса в терминах другого. Повторное использование за счет порождения подкласса называют еще прозрачным ящиком (whitebox reuse).
Такой термин подчеркивает, что внутреннее устройство родительских
классов видимо подклассам.
Композиция объектов - это альтернатива наследованию класса. В этом случае
новую, более сложную функциональность мы получаем путем объединения или
композиции объектов. Для композиции требуется, чтобы объединяемые объекты
имели четко определенные интерфейсы. Такой способ повторного использования
называют черным ящиком (black-box reuse), поскольку детали внутреннего устройства объектов остаются скрытыми.
И у наследования, и у композиции есть достоинства и недостатки. Наследование класса определяется статически на этапе компиляции, его проще использовать,
поскольку оно напрямую поддержано языком программирования. В случае
наследования классов упрощается также задача модификации существующей реализации. Если подкласс замещает лишь некоторые операции, то могут оказаться
затронутыми и остальные унаследованные операции, поскольку не исключено,
что они вызывают замещенные.
Но у наследования класса есть и минусы. Во-первых, нельзя изменить унаследованную от родителя реализацию во время выполнения программы, поскольку
само наследование фиксировано на этапе компиляции. Во-вторых, родительский
класс нередко хотя бы частично определяет физическое представление своих подклассов. Поскольку подклассу доступны детали реализации родительского класса,
то часто говорят, что наследование нарушает инкапсуляцию [Sny86]. Реализации
подкласса и родительского класса настолько тесно связаны, что любые изменения последней требуют изменять и реализацию подкласса.
Зависимость от реализации может повлечь за собой проблемы при попытке
повторного использования подкласса. Если хотя бы один аспект унаследованной
реализации непригоден для новой предметной области, то приходится переписывать родительский класс или заменять его чем-то более подходящим.
Такая зависимость ограничивает гибкость и возможности повторного использования. С проблемой можно справиться, если наследовать только абстрактным классам, поскольку
в них обычно совсем нет реализации или она минимальна.

Композиция объектов определяется динамически во время выполнения за
счет того, что объекты получают ссылки на другие объекты. Композицию можно
применить, если объекты соблюдают интерфейсы друг друга. Для этого, в свою
очередь, требуется тщательно проектировать интерфейсы, так чтобы один объект
можно было использовать вместе с широким спектром других. Но и выигрыш велик. Поскольку доступ к объектам осуществляется только через их интерфейсы,
мы не нарушаем инкапсуляцию. Во время выполнения программы любой объект
можно заменить другим, лишь бы он имел тот же тип. Более того, поскольку при
реализации объекта кодируются прежде всего его интерфейсы, то зависимость от
реализации резко снижается.
Композиция объектов влияет на дизайн системы и еще в одном аспекте. Отдавая предпочтение композиции объектов, а не
наследованию классов, вы инкапсулируете каждый класс и даете ему возможность выполнять только свою задачу.
Классы и их иерархии остаются небольшими, и вероятность их разрастания до
неуправляемых размеров невелика. С другой стороны, дизайн, основанный на
композиции, будет содержать больше объектов (хотя число классов, возможно,
уменьшится), и поведение системы начнет зависеть от их взаимодействия, тогда
как при другом подходе оно было бы определено в одном классе.
Это подводит нас ко второму правилу объектно-ориентированного проектирования: предпочитайте композицию наследованию класса.

В идеале, чтобы добиться повторного использования, вообще не следовало
бы создавать новые компоненты. Хорошо бы, чтобы можно было получить всю
нужную функциональность, просто собирая вместе уже существующие компоненты. На практике, однако, так получается редко, поскольку набор имеющихся
компонентов все же недостаточно широк. Повторное использование за счет наследования упрощает создание новых компонентов, которые можно было бы
применять со старыми. Поэтому наследование и композиция часто используются вместе.
Тем не менее,наш опыт показывает, что проектировщики злоупотребляют наследованием. Нередко дизайн мог бы стать лучше и проще, если бы автор больше
полагался на композицию объектов.

Абстрактная Фабрика:
    Назначение: Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.

    Плюсы: Изолирует конкретные классы
           Упрощает замену семейств продуктов
           Гарантирует сочетаемость продуктов

    Минусы: Поддержать новый вид продуктов трудно

Builder (Строитель):
    Назначение: Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же
    процесса конструирования могут получаться разные представления.

    Плюсы: позволяет изменять внутреннее представление продукта
           изолирует код, реализующий конструирование и представление
           дает более тонкий контроль над процессом конструирования


*/



public class Introduction {


}
