package serialization_23;


/* Если вы сериализуете объект, то должны иметь класс для его
десериализации и дальнейшего использования. Это очевидно. Но
что произойдет, если вы за это время измените класс?


Изменения класса, которые могут навредить десериализации:
    1. Удаление переменной экземпляра.
    2. Изменение объявленного типа переменной.
    3. Замена непереходной переменной на переходную.
    4. Перемещение класса вверх или вниз по иерархии наследования.
    5. Изменение класса (где угодно в графе объекта) из Serializable
    в не-Serializable (удаляя implements Serializable из объявления класса).
    6. Превращение обычной переменной в статическую.

Допустимые изменения класса:
    1. Добавление новых переменных в класс (существующие объекты
    будут десериализованы со значениями по умолчанию для переменных,
    которых они не имели до сериализации).
    2. Добавление классов к иерархии наследования.
    3. Удаление классов из иерархии наследования.
    4. Изменение уровня доступа переменной не влияет на способность
    десериализации присваивать ей значение.
    5. Замена непереходной переменной на переходную (ранее сериализованные
    объекты имели значение по умолчанию для переменных, которые до
    этого были переходными).

Каждый раз, когда объект сериализуется, он вместе со всеми объектами в
графе «маркируется» идентификационным номером версии своего класса.
Этот номер (ID) называют serialVersionUlD. Он вычисляется на основании
информации о структуре класса. Если класс был изменен после сериализации,
то при десериализации объекта он может иметь уже другой serialVersionUlD
и операция провалится. Но вы можете контролировать этот процесс.

Если есть хоть какая-то возможность, что ваш класс мог поменяться, добавьте в него
серийный идентификационный номер версии. Когда Java пробует десериализовать объект,
сравнивается serialVersionUlD сериализованного объекта с serialVersionUlD класса,
используемого JVM. Например, экземпляр класса Dog был сериализован с ID 23 (в
действительности serialVersionUlD намного длиннее). Когда J VM десериализует
объект Dog, то сначала сравнивает serialVersionUlD объекта Dog с serialVersionUlD
класса Dog. Если числа не совпадают, то JVM предполагает, что класс не совместим
с ранее сериализованным объектом и во время десериализации вы получаете исключение.
Итак, решение состоит в том, чтобы поместить serialVersionUlD в ваш класс, и
тогда, даже если ваш класс будет развиваться, его serialVersionUlD останется
прежним, a JVM скажет: «Хорошо, круто, класс  совместим с этим сериализованным
объектом», даже если класс фактически изменился. Это работает, если только вы
будете осторожно изменять класс! Другими словами, вы берете на себя всю
ответственность за любые проблемы, которые могут возникнуть, когда более старый
объект будет восстанавливаться более новым классом.

File > Settings > Plugins > Browse repositories > GenerateSerialVersionUID
File => Settings... => Inspections => Serialization issues =>  Serializable class without 'serialVersionUID'
*/


import java.io.Serializable;

public class SerialVersionUlD implements Serializable {

    private static final long serialVersionUID = 7222064118531887481L;

    public static void main(String[] args) {

    }
}
