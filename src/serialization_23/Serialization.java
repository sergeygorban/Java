package serialization_23;


/* СЕРЕАЛИЗАЦИЯ

Сереализация - это сохранение состояния объекта

Чтобы сделать что-нибудь полезное, часто приходится связывать по меньшей мере два потока —
один из них играет роль соединения, а другой вызывает методы. Почему два? Потому что потоки для
соединений обычно низкоуровневые. FileOutputStream (поток для соединения), к примеру, имеет
методы для записи байтов. Но нужно записывать не байты, а объекты, так что понадобится
высокоуровневый цепной поток.
Хорошо, тогда почему бы не использовать одиночный поток, который точно сделает то, что
нужно? Поток, который позволит записывать объекты, но при этом будет преобразовывать их в байты.
Нужно мыслить категориями объектно ориентированного программирования. Каждый класс делает
хорошо только одну вещь: FileOutputStream записывает байты в файл; ObjectOutputStream
преобразует объекты в данные, которые могут быть записаны в поток. Мы создаем FileOutputStream,
который позволяет делать записи в файл, и прикрепляем к нему ObjectOutputStream (цепной поток).
Когда мы вызываем метод writeObject() из объекта ObjectOutputStream, объект подключается к
потоку и переходит к FileOutputStream, где в результате записывается в файл в виде байтов.

Объект - Объект сериализуется и записывается в ObjectOutputStream(цепной поток) -
ObjectOutputStream преобразует объект в байты, связывается с FileOutputStream(поток для соединения) -
FileOutputStream записывает байты в Файл. В файл, при сериализации, записываются переменные экземпляра
класса и краткая информация необходимая JVM для востановления объекта (сведения о типе класса).

Сериализованные объекты сохраняют значения переменных, чтобы идентичный экземпляр
(объект) можно было вернуть обратно в кучу.

При сериализации объекта также сериализуются все объекты, на которые он ссылается с помощью
своих переменных экземпляра. И все объекты, на которые ссылаются те объекты, тоже сериализуются.
И все объекты, на которые ссылаются те объекты, тоже сериализуются...
Сериализация сохраняет полный граф объекта.

Интерфейс Serializable известен как разметочный, или теговый, потому что не содержит методов.
Его единственная цель — объявить, что класс сериализуемый (serializable). Другими
словами, объекты данного типа сохраняются с применением механизма сериализации.
Если какой-либо предок класса будет сериализуемым, то его потомки также автоматически станут
таковыми, даже если явно не объявляют реализацию Serializable.
Интерфейсы всегда так работают.
Либо полный граф объекта будет корректно сериализован,
либо вся операция провалится. Вы не можете сериализовать объект Pond, если переменная экземпляра
отказывается сериализовываться (из-за того, что не добавлен интерфейс Serializable).

Если вы хотите, чтобы в процессе сериализации была пропущена какая-либо переменная экземпляра,
пометьте ее ключевым словом transient (переходный). Несмотря на то что большинство элементов
в библиотеках классов Java сериализуемы, вы не можете сохранять их как сетевые соединения,
потоки или файловые объекты. Они зависят от процесса выполнения  программы и могут меняться
при каждом запуске. Другими словами, их экземпляры уникальны для каждого запуска вашей
программы, для платформы, на которой она выполняется, для определенной версии JVM. Как только
программа закрывается, в понятном виде эти элементы уже не вернуть — каждый раз их нужно
создавать с нуля. Такие элементы помечаются  transient, чтобы не включать их при сериализации

Статические переменные не сериализуются! Нет смысла сохранять значение статической
переменной как часть состояния объекта, так как все объекты данного типа используют только
значение, находящееся в классе. */


import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class Serialization implements Serializable {

    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public Serialization(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public static void main(String[] args) throws IOException {

        FileOutputStream fileStream = new FileOutputStream("Obj.ser");
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileStream);

        objectOutputStream.writeObject(new Serialization("Roc", 23));
        objectOutputStream.writeObject(new Serialization("Rc", 24));
        objectOutputStream.close();

    }
}
