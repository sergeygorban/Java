package dataStructures_20;

/* Как упоминалось выше, обычная (односторонняя) очередь позволяет эффективно
вводить элементы в свой хвост и удалять элементы из своей головы, а двухсторонняя
очередь — вводить и удалять элементы на обоих своих концах, хотя ввод элементов
в середине очереди не поддерживается. В версии Java SE 6 появился интерфейс Deque,
реализуемый классами ArrayDeque и LinkedList, причем оба класса предоставляют
двухстороннюю очередь, которая может расти по мере надобности.


В очередях по приоритету элементы извлекаются в отсортированном порядке после того, как они были введены в произвольном порядке. Следовательно, в результате
каждого вызова метода remove () получается наименьший из элементов, находящихся в очереди. Но в очереди по приоритету сортируются не все ее элементы. Если выполняется перебор элементов такой очереди, они совсем не обязательно оказываются
отсортированными. В очереди по приоритету применяется изящная и эффективная
структура данных — так называемая "куча" — это самоорганизующееся двоичное дерево, в котором операции ввода и удаления вызывают перемещение наименьшего
элемента в корень, не тратя времени на сортировку всех элементов очереди.

Подобно древовидному множеству, очередь по приоритету может содержать элементы класса, реализующего интерфейс Comparable, или же принимать объект типа
Comparator, предоставляемый конструктору ее класса. Как правило, очередь по приоритету применяется для планирования заданий на выполнение. У каждого задания имеется
свой приоритет. Задания вводятся в очередь в случайном порядке. Когда новое задание
может быть запущено на выполнение, наиболее высокоприоритетное задание удаляется
из очереди. (По традиции приоритет 1 считается наивысшим, поэтому в результате операции удаления из очереди извлекается элемент с наименьшим приоритетом.)


*/
public class QueuesMy {
}
