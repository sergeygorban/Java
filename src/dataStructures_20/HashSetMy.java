package dataStructures_20;


/* Когда вы помещаете объект в множество HashSet, оно использует значение
идентификатора объекта, чтобы определить, где именно тот будет размещен.
При этом идентификатор сравнивается с идентификаторами всех элементов
внутри HashSet. Если совпадений нет, то подразумевается, что новый
объект не дублирует никакой другой. Иными словами, если идентификаторы
различаются, то HashSet уверено, что объекты не могут быть равны!
Для того чтобы они все же совпали, необходимо переопределить метод hashCode().
Но даже если два объекта возвращают  одинаковое значение hashCode(),
они все еще могут быть не равны (более подробно об этом на следующей
странице). Видя два одинаковых идентификатора у объектов, один из которых
добавляется в множество, а другой уже там находится, HashSet вызывает метод equals(),
принадлежащий одному из объектов, чтобы убедиться, что они действительно эквивалентны.
Удостоверившись в этом, HashSet будет знать, что при добавлении такого объекта произойдет
дублирование, значит, он не попадет в множество. Вы не получите исключение, но метод add(),
принадлежащий HashSet, возвращает булево значение, чтобы сообщить, был ли добавлен
новый объект (если вас это интересует). Когда add() возвратит false, вы будете знать, что новый
объект дублирует один из элементов множества.

Связные списки и массивы позволяют указывать порядок, в котором должны следовать элементы. Но если вам нужно найти конкретный элемент, а вы не помните
его позицию в коллекции, то придется перебирать все элементы до тех пор, пока
не будет обнаружено совпадение по критерию поиска. На это может потребоваться некоторое время, если коллекция содержит достаточно много элементов. Если же
порядок расположения элементов не имеет особого значения, то для подобных случаев предусмотрены структуры данных, которые позволяют намного быстрее находить элементы в коллекции. Но недостаток таких структур данных заключается в том,
что они не обеспечивают никакого контроля над порядком расположения элементов
в коллекции. Эти структуры данных организуют элементы в том порядке, который
удобен для их собственных целей.
К числу широко известных структур данных для быстрого нахождения объектов
относится так называемая хеш-таблица, которая вычисляет для каждого объекта целочисленное значение, называемое хеги-кодом.

В Java хеш-таблицы реализованы в виде массивов связных списков. Каждый такой
список называется группой

Хеш-таблицы можно использовать для реализации ряда важных структур данных.
Простейшая из них относится к типу множества. Множество — это совокупность элементов, не содержащая дубликатов.

*/

import java.util.ArrayList;
import java.util.HashSet;

public class HashSetMy {

    public static void main(String[] args) {


        ArrayList<ListObg> listObj = new ArrayList<ListObg>();
        listObj.add(new ListObg("Asd",24));
        listObj.add(new ListObg("Dfg",35));
        listObj.add(new ListObg("Rty",100));

        /* После переопределения hashCode и equals,
        одинаковые объекты не добавляются */
        HashSet<ListObg> hashSet = new HashSet<ListObg>();
        hashSet.addAll(listObj);
        hashSet.add(new ListObg("Asd", 24));
        hashSet.add(new ListObg("Asd", 24));
        hashSet.add(new ListObg("gbn", 33));


        System.out.println(hashSet);


    }
}
