package dataStructures_20;


/*Добавление элемента в ArrayListMy происходит медленнее,
если при этом задается его конкретная позиция, отличная от конца списка.
Поэтому метод add(index, element) работает не так быстро,как add(element).

Класс ArrayList является обобщенным с параметром типа.

Списочный массив управляет внутренним массивом ссылок на объекты.
В конечном итоге элементы массива могут оказаться исчерпаными.
И здесь на помощь приходят специальные средства списочного массива.
Так, если метод add() вызывается при заполненном внутреннем массиве,
из списочного массива автоматически создается массив большего размера,
куда копируются все объекты. Если заранее известно, сколько элементов
требуется хранить в массиве, то перед заполнением списочного массива
достаточно вызвать метод ensureCapacity(). При вызове этого метода
выделяется память для внутреннего массива, состоящего из 20 объектов.
Затем можно вызвать метод add(), который уже не будет испытывать
затруднений при перераспределении памяти.

Первоначальную емкость списочного массива можно передать конструктору
класса ArrayList в качестве параметра

Выделение памяти для списочного и обычного массивов происходит по-разному. Так,
приведенные ниже выражения не равнозначны.
new ArrayList<Employee>(100) // емкость списочного массива равна 100
new Employee[100] // размер обычного массива равен 100
Между емкостью списочного массива и размером обычного массива имеется
существенное отличие. Если выделить память для массива из 100 элементов,
она будет зарезервирована для дальнейшего использования именно такого количества
элементов массива. В то же время емкость списочного массива — это всего
лишь возможная величина. В ходе работы она может быть увеличена
[за счет выделения дополнительной памяти), но сразу после создания списочный
массив не содержит ни одного элемента.

Если вы уверены, что списочный массив будет иметь постоянный размер, можете
вызвать метод trimToSize (), который устанавливает размер блока памяти таким
образом, чтобы он точно соответствовал количеству хранимых элементов. Система
сборки "мусора" предотвращает неэффективное использование памяти, освобождая
ее излишки. Если добавить новые элементы в списочный массив после усечения
его размера методом trimToSize(), блок памяти будет перемещен, на что
потребуется дополнительное время. Поэтому вызывать данный метод следует лишь в
том случае, когда точно известно, что дополнительные элементы в списочный массив
вводиться не будут.

К сожалению, ничто не дается бесплатно. За удобство, предоставляемое автоматическим
регулированием размера списочного массива, приходится расплачиваться
более сложным синтаксисом, который требуется для доступа к его элементам.
Дело в том, что класс Array List не входит в состав Java, а является лишь служебным
классом, специально введенным в стандартную библиотеку этого языка.
Вместо удобных квадратных скобок для доступа к элементам списочного массива
приходится вызывать методы get() и set()

При вставке элемента методом add() по индексу n, происходит следующее: Элемент по индексу
n и следующие за ним элементы сдвигаются, чтобы освободить место для нового элемента.
Если после вставки элемента новый размер списочного массива превышает его емкость,
происходит копирование массива.

Аналогично можно удалить элемент из середины списочного массива.
Элементы, следующие после удаленного элемента, сдвигаются влево, а размер
списочного массива уменьшается на единицу. Вставка и удаление элементов списочного
массива не особенно эффективна. Для массивов, размеры которых невелики, это
не имеет особого значения. Но если при обработке больших объемов данных приходится
часто вставлять и удалять элементы, попробуйте вместо списочного массива
воспользоваться связным списком.

*/


import java.util.*;


public class ArrayListMy {

    public static void main(String[] args) {



        ArrayList<String> list = new ArrayList();
        list.ensureCapacity(20);

        list.add("Sort");
        list.add("Aort");
        list.add("Nort");
        list.add("Kort");
        list.add("Port");

        System.out.println(list);

        /* Определение первоначальглшл размера массива*/
        ArrayList<Integer> listInt = new ArrayList<>(2);
        listInt.add(2);
        listInt.add(3);
        listInt.add(5);

        /* Возвращается текущее количество элементов в массиве */
        System.out.println(list.size());

        /* Доступ к элементам списочного массива и их изменение*/
        System.out.println(list.get(1));
        System.out.println(list.set(1,"!!!!!"));
        System.out.println(list.get(1));

        /* Емкость списочного массива равна 5, а его размер - 0*/
        ArrayList<Integer> list2 = new ArrayList<>(5);
        System.out.println(list2.size());

        /* Удаление элементов */
        list.remove(4);
        System.out.println(list);


        /* Сортировка списка, состоящего не из объектов*/
        Collections.sort(list);
        System.out.println(list);

        /* Перебор элементов */
        for (String i: list) {
            System.out.println(i);
        }


    }
}
