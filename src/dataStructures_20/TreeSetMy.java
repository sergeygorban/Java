package dataStructures_20;

/* Хранит элементы отсортированными и предотвращает дублирование.

Этот класс отлично подходит для тех случаев, когда вам нужно множество
(мы поговорим о них совсем скоро) или когда вы знаете, что список всегда
должен оставаться отсортированным в алфавитном порядке. С другой стороны,
если вам не нужно, чтобы список оставался отсортированным, TreeSetMy может
оказаться избыточным — каждый раз, когда вы добавляете в него элементу
класс тратит время на поиск места для этого элемента.

Множество TreeSetMy, как и HashSet, предотвращает дублирование элементов.
Кроме того, оно сохраняет их отсортированными. Это работает аналогично методу sort() — при
создании экземпляра TreeSet с помощью конструктора, не принимающего аргументы, для
сортировки будет применяться метод compareTo() каждого элемента. Но вместо этого вы можете
передать Comparator в консгруктор TreeSet. Недостаток множества заключается в том, что,
если вам не нужна сортировка, вы все равно расплачиваетесь за нее снижением
производительности. Но для большинства приложений этот эффект будет практически незаметен.

Для использования TreeSet должно выполняться одно из этих условий:
    1. Элементы в списке обязаны иметь тип, который реализует
       интерфейс Comparable.

    или
    2. При создании TreeSet вы используете перегруженный конструктор, который
    принимает Comparator

Класс TreeSet реализует древовидное множество, подобное хеш-множеству, но
с одним дополнительным усовершенствованием: древовидное множество представляет собой отсортированную коллекцию. В такую коллекцию можно вводить элементы
в любом порядке. Когда же выполняется перебор ее элементов, извлекаемые из нее значения оказываются автоматически отсортированными.

Как следует из имени класса TreeSet, сортировка обеспечивается древовидной
структурой данных. (В текущей реализации используется структура так называемого
красно-черного дерева.






*/

import java.util.TreeSet;

public class TreeSetMy {

    public static void main(String[] args) {

        TreeSet<ListObg> treeSet = new TreeSet<ListObg>();
        treeSet.add(new ListObg("Asd", 24));
        treeSet.add(new ListObg("Asd", 24));
        treeSet.add(new ListObg("gbn", 33));
        treeSet.add(new ListObg("tr", 66));
        treeSet.add(new ListObg("bn", 55));
        treeSet.add(new ListObg("xcv", 33));

        System.out.println(treeSet);

        TreeSet<ListObg> treeSet1 = new TreeSet<ListObg>(new ComparatorMy());
        treeSet1.add(new ListObg("Asd", 24));
        treeSet1.add(new ListObg("Asd", 24));
        treeSet1.add(new ListObg("gbn", 33));
        treeSet1.add(new ListObg("tr", 66));
        treeSet1.add(new ListObg("bn", 55));
        treeSet1.add(new ListObg("xcv", 33));

        System.out.println(treeSet1);
    }


}
