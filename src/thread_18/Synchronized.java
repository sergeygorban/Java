package thread_18;

/* Использование потоков может сопровождаться проблемами
"параллелизма". Проблемы параллелизма вызывают «состояние гонки» (одна из
классических ошибок проектирования). Такое состояние приводит к повреждению
данных. Все это ведет к одному потенциально смертельному сценарию:
два или больше потоков имеют доступ к данным одного объекта. Иными словами,
методы, которые выполняются в двух разных стеках, вызывают, например,
геттеры или сеттеры из одного и того же объекта в куче. Вот уж действительно
«левая рука не знает, что делает правая». Два потока, отрешенных от всего
мира, вызывают в одиночку свои методы, и каждый думает, что именно он,
единственный и неповторимый, имеет значение. В конце концов когда поток
становится работоспособным (или заблокированным), он как будто теряет сознание.
И когда работа возобновляется, поток не знает, что его останавливали.

synchronized - ключевое слово, которое позволяет методу выполняться только
в одном потоке. Цель синхронизации — защита критически важных данных. Но
помните, что вы не  блокируете данные, а синхронизируете методы, которые с
ними работают.

Синхронизация имеет свои побочные эффекты. Во-первых, синхронизированный
метод обладает определенной избыточностью. Иными словами, когда выполнение кода
доходит до такого метода, снижается производительность (хотя, скорее всего,
вы этого даже не замечаете), так как дается ответ на вопрос. Доступен ли ключ?
Во-вторых, синхронизированный метод может  замедлить вашу программу, потому
что синхронизация ограничивает распараллеливание. Метод вынуждает
другие потоки выстраиваться в ряд и ждать своей очереди. Эта проблема может
быть неактуальна для вашего кода, но ее нужно учитывать. В-третьих,
синхронизированные методы могут  привести к взаимной блокировке, а это
самое страшное! Хорошее практическое решение — синхронизация
минимально необходимого количества методов, которые не могут без этого
обойтись. Фактически вы можете синхронизировать не только методы, но
и более мелкие участки кода. Ключевое слово synchronized можно применять даже к
одному или нескольким выражениям.

Будьте осторожны при синхронизации кода, так как для программы нет
ничего опаснее, чем взаимное блокирование. Взаимное блокирование двух
потоков происходит тогда, когда каждый из них содержит ключ, который
нужен другому потоку. Нет никакой возможности выйти из этой ситуации,
поэтому потоки просто остановятся и будут ждать.
Если вы знакомы с базами данных или другими серверными
приложениями, то наверняка уловили суть проблемы — базы данных часто
обладают механизмом блокирования наподобие синхронизации. Настоящая
система по управлению транзакциями способна справиться с отдельными
случаями взаимного блокирования. Она может распознать их, например,
когда две транзакции выполняются слишком долго. Но в отличие от Java
такие серверные приложения умеют делать «откат», когда состояние
данных возвращается к моменту до выполнения транзакции (атомарность
в действии).
У Java нет механизмов для противодействия взаимному блокированию.
JVM даже не будет знать, что это случилось. Будьте осторожны при
проектировании, так как вся ответственность лежит на вас. Если вам
придется часто писать многопоточный код, то ознакомьтесь с книгой «Java
Threads» Скотта Оакса (Scott Oaks) и Генри Вонга (Henry Wong). В ней
содержатся советы, которые помогут избежать взаимного блокирования.
Одна из основных рекомендаций — уделять внимание порядку, в котором
запускаются потоки.

*/

public class Synchronized {
}
