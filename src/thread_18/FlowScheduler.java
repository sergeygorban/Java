package thread_18;


/* Планировщик принимает все решения о том, какой поток из работоспособного превращается в работающий
и в какой момент (и при каких обстоятельствах) он должен изменить свое состояние обратно. Планировщик
решает, кто и как долго должен работать, а также что случается с потоками, когда они перестают выполняться.
Вы не можете управлять планировщиком. Для этого не предусмотрено соответствующих методов. Что еще более
важно, процесс планирования потоков не дает вам гарантий (выполнение некоторых принципов по- ^
чти гарантируется, но это очень неопределенно)! Главный вывод, который из этого следует: не
допускайте, чтобы корректная работа вашего  приложения зависела от конкретной модели поведения
планировщика] Для разных версий JVM существуют различные реализации планировщиков, и даже одна
программа на одном и том же компьютере может выдавать разные результаты. Одна из грубейших ошибок
начинающих Java-программистов заключается в том, что они тестируют многопоточное приложение на единственной
системе. При этом они надеются, что планировщик потоков будет работать одинаково в любой системе.
Что это означает с точки зрения принципа — «пиши один код — запускай его везде»? Все просто: чтобы
можно было писать код, совместимый с различными системами, ваша многопоточная программа должна
работать независимо от поведения планировщика потоков. Например, вы не можете рассчитывать на то, что
планировщик обеспечит идеально паритетное выполнение потоков. Хотя в нынешних реалиях трудно себе
представить, что планировщик скажет вашему приложению нечто вроде «Хорошо, поток № 5, ты в деле, pi пока я за
тебя отвечаю, можешь оставаться здесь до самого  завершения метода run()».
Секрет кроется в приостановке. Приостанавливая поток даже на несколько миллисекунд, вы заставляете
его изменить свое состояние и уступить место другому потоку. Метод sleep() гарантирует выполнение одного
правила: приостановленный поток не вернется к работе, пока не истечет срок его приостановки. Например, если
вы прикажете своему потоку остановиться на две  секунды (2000 мс), он ни за что не продолжит свою работу до
истечения этого времени (но это не значит, что он возобновится сразу через две секунды).
*/


public class FlowScheduler implements Runnable {

    // Непредсказуемость планировщика потоков
    public void go() {
        System.out.println("The top of the stack");
    }
    @Override
    public void run() {
        go();
    }


    public static void main(String[] args) {

        Runnable flowScheduler = new FlowScheduler();
        Thread thread = new Thread(flowScheduler);

        // Запуск потока
        thread.start();
        System.out.println("Return to Main");

    }
}
