package thread_18;


/* ThreadMy — это класс, который представляет собой исполняемый
поток. Он содержит методы для запуска и приостановления потока,
для присоединения одного потока к другому

Поток выполняется отдельно. Это означает, что у него есть свой
стек вызовов. Любая Java-программа создает главный поток,
который на дне своего стека содержит метод Main(). За запуск
главного потока отвечает JVM (она контролирует и другие потоки,
например поток для сборки мусора). Как программист вы можете
написать код для создания собственных потоков.

При наличии нескольких стеков вызовов создается видимость того, что
разные действия выполняются одновременно. На практике только
настоящая мультипроцессорная система способна выполнять несколько операций
в один момент времени. В случае с потоками в Java управление может
переходить от одного стека к другому настолько быстро, что создается
впечатление, будто все стеки выполняются одновременно. Помните, Java — это всего
лишь процесс, работающий под управлением исходной ОС. Итак, Java сам
представляет собой «текущий процесс», выполняющийся в операционной
системе.

Последовательность работы потоков:
    1. JVM вызывает метод Main() - главный поток
    2. Метод Main() запускает новый поток (thread_18.start() - пользовательский поток).
    Главный поток временно приостановлен, пока стартует новый поток.
    3. JVM переключается между новым потоком (пользовательским потоком) и исходным
    главным потоком, пока оба не завершатся.

Runnable — это интерфейс, который дает задачу, для выполнения потоком

Три состояния потока:

    1. Новый: Экземпляр класса Thread создан, но не запущен.
    Иначе говоря, есть объект Thread, но нет исполняемого потока.
    2. Работоспособный: Когда вы запускаете поток, он становится работоспособным.
    Это означает, что он готов к выполнению и просто ждет своей очереди. На этом этапе
    у потока уже есть свой стек вызовов.
    3. Работающий: Это состояние, которое страстно желает обрести любой поток! Стать избранным.
    Потоком, выполняющимся в данный момент. Только планировщик потоков из JVM может
    принять такое решение. Иногда можно на него повлиять, но нельзя заставить поток
    работать. В этом состоянии поток (именно данный поток) содержит активный стек
    вызовов, а метод на его вершине выполняется.
Но это еще не все. Став работоспособным, поток может менять свое состояние с работающего
и обратно, а также становиться временно неработоспособным (или заблокированным).
Планировщик может сделать работающий поток заблокированным. Для этого есть несколько причин.
Например, в потоке выполняется код для чтения входящих данных из сокета, но данные там не
обнаруживаются. Планировщик может блокировать поток до тех пор, пока что-то не станет доступно.
Или исполняемый код может сказать  потоку, чтобы тот приостановил свою работу (sleep()).
Или поток может ждать ответа от метода, чей объект заблокирован. В таком случае
потоку нельзя продолжать свою работу, пока другой поток не освободит этот объект.
Все эти (и другие) условия приводят к тому, что поток становится временно неработоспособным.

У интерфейса Runnable есть всего один  метод — run(). Именно он помещается на дно
нового стека вызовов. Проще говоря, это первый метод, который будет запущен в новом потоке.

Когда вы запускаете поток (вызывая из объекта Thread метод startO), создается новый
стек, на дне которого находится метод run() из Runnable. В этом состоянии поток считается
работоспособным, он ожидает, когда его  выберут для выполнения.

Поток считается работающим, когда планировщик потоков в JVM выбирает его для
выполнения в текущий момент. На  однопроцессорном компьютере может быть лишь один
такой поток.



*/

public class ThreadMy implements Runnable {

    public void go() {
        System.out.println("The top of the stack");
    }
    @Override
    public void run() {
        go();
    }


    public static void main(String[] args) {

        Runnable threadMy = new ThreadMy();
        Thread thread = new Thread(threadMy);


        // Запуск потока
        thread.start();
        System.out.println("Return to Main");

    }
}
